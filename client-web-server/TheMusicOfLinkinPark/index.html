<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="data:;base64,=">
        <title>The Music Of Linkin Park Web Concert</title>
        <style>
            /* canvas { width: 600; height: 300 } */
            body { 
                margin: 0;
                overflow: hidden;
            }
            #welcome-text {
                text-align: center; 
                position: fixed; 
                z-index: 10; 
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            #username-input {
                text-align: center; 
                position: fixed; 
                z-index: 10; 
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            #join-button {
                text-align: center; 
                position: fixed; 
                z-index: 10; 
                top: 60%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js" integrity="sha512-aNMyYYxdIxIaot0Y1/PLuEu3eipGCmsEUBrUq+7aVyPGMFH8z0eTP0tkqAvv34fzN6z+201d3T8HPb1svWSKHQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <h1 id="welcome-text"> The Music of Linkin Pak Web Concert, ask your friends for the URL now!</h1>
        <input type="text" value="" id="username-input" size="30"/>
        <input type="button" value="Join Concert" id="join-button" onclick="joinConcert()"/>
        <script>
            
            let roomId = null;
            // Initialize room Id if present

            function giveUserMsgThroughLabel(obj) {
                document.getElementById("welcome-text").innerHTML = obj;
            }

            function isRoomIdAvailable() {
                return roomId != null;
            }

            function hasPeerConnectedToConcertRoomOnce() {
                return Object.keys(peer.connections).length > 0 && hostConnection != null;
            }

            function hideStartingUI() {
                document.getElementById("welcome-text").style.display = "none";
                document.getElementById("username-input").style.display = "none";
                document.getElementById("join-button").style.display = "none";
            }

            function writeFinalPropertyOfObject(object, property, value) {
                Object.defineProperty( object, property, {
                    value: value, //  Makes obj.<key> unwritable and final
                    writable: false,
                    enumerable: true,
                    configurable: true
                });
            }

            joinConcert = () => {
                let usernameTextField = document.getElementById("username-input");
                let value = usernameTextField.value;
                if(!value || value === null || value === '') {
                    giveUserMsgThroughLabel("Invalid username: " + value + ", try another username");
                } else {
                    if(isRoomIdAvailable() && hasPeerConnectedToConcertRoomOnce()) {
                        hostConnection.send('');
                    } else {
                        console.log("Something Went Wrong when starting concert: ", roomId, peer.connections, hostConnection);
                    }
                }
            }

            const peer = new Peer();
            let hostConnection = null;

            peer.on('open', function(id) {
                try {
                    let url = window.location.search;
                    console.log("URL RECEIVED: " + url);
                    let getQuery = url.split('?')[1];
                    let pair = getQuery.split('=');
                    
                    if(pair[0] === "RoomId" && typeof pair[1] === "string") {
                        roomId = pair[1];
                        giveUserMsgThroughLabel("Establishing Connection to Web Concert...");
                    }
                } catch (error) {
                    console.log( new Error("Invalid URL: " + window.location.search) );
                }
                console.log("Connected: " + peer.id);
                    
                try {
                    hostConnection = peer.connect(roomId);
                    hostConnection.on('open', function() {
                        giveUserMsgThroughLabel("Web Concert Connectd: Enter Your Name to Start!");
                        // Send messages
                        // conn.send('get-info');
                    });
                    hostConnection.on('data', function(data) {
                        // Receive messages
                        console.log('Received', data);

                        if(data["active"] === false) {
                            giveUserMsgThroughLabel("Waiting for HOST To Start Web Concert");
                        } else if (data["active"] === true) {
                            hideStartingUI();
                            loadFirstSong();   // Load nth song if client is joining in the middle
                        } else {
                            throw new Error("Invalid data: " + data);
                        }
                    });
                } catch (error) {
                    console.log(error);
                }
            });

            source = null;
            analyser = null;
            gainNode = null;

            canvas = document.getElementById("canvas");
            canvas.height = window.innerHeight;
            canvas.width = window.innerWidth;
            canvasCtx = canvas.getContext("2d");
            WIDTH = canvas.width;
            HEIGHT = canvas.height;

            timeDataArrayLength = 256;
            timeDataArray = new Float32Array(timeDataArrayLength);
            secondTimeDerivative = new Float32Array(timeDataArrayLength);
            firstTimeDerivative = new Float32Array(timeDataArrayLength);

            allSongs = [];
            currentSongIndex = 0;

            function allSongsDoneLoading() {
                for(let i = 0; i < allSongs.length; i++) {
                    if(! allSongs[i].isAudioLoaded()) return false;
                }
                return true;
            }

            function getCurrentSong() {
                return allSongs[currentSongIndex];
            }
            function cueInNextSong() {
                currentSongIndex++;

                // Dont do anything if all songs have been played
                if(currentSongIndex < allSongs.length) {
                    oldSource = source;
                    source = audioCtx.createBufferSource();
                    oldSource.disconnect();
                    source.connect(analyser);

                    getCurrentSong().start(source);
                    source.start(0);
                }
            }

            window.onload = () => {
                audioCtx = new AudioContext();
                analyser = audioCtx.createAnalyser();
                source = audioCtx.createBufferSource();
                gainNode = audioCtx.createGain();

                // Initialise Audio graph parameters
                source.onended = cueInNextSong;
                gainNode.gain.value = 0.1; // 10 %
                analyser.fftSize = getTimeDataArray().length;
                
                // Initialise Audio graph
                gainNode.connect(audioCtx.destination);
                analyser.connect(gainNode);
                source.connect(analyser);
            };

            function getTimeDataArray() {
                // Return smoothed array for the songs to use for drawing
                return secondTimeDerivative;
            }

            
        </script>
        
        <script>
            // Draw UI
            const MIN_VOLUME = 0.0, MAX_VOLUME = 2.0;
            const UICornerMargin = Math.min(WIDTH * 0.05, HEIGHT * 0.05);
            const volumeControlX = UICornerMargin, volumeControlY = HEIGHT - UICornerMargin;
            const volumeControlHalfHeight = 20, volumeControlWidth = 3, volumeControlBarWidth = 1;

            function drawUI () {

                canvasCtx.lineWidth = volumeControlBarWidth;
                canvasCtx.strokeStyle = "#fff";
                canvasCtx.beginPath();
                canvasCtx.moveTo(volumeControlX, volumeControlY - volumeControlHalfHeight);
                canvasCtx.lineTo(volumeControlX, volumeControlY + volumeControlHalfHeight);
                canvasCtx.stroke();
                canvasCtx.closePath();

                const currentVolume = gainNode.gain.value;
                const volumeFractionOfTotal = (currentVolume / MAX_VOLUME) * volumeControlHalfHeight * 2;
                const volumeControlPosition = volumeControlY + volumeControlHalfHeight - volumeFractionOfTotal;
                canvasCtx.lineWidth = volumeControlWidth;
                canvasCtx.strokeStyle = "#fff";
                canvasCtx.beginPath();
                canvasCtx.moveTo(volumeControlX - volumeControlWidth, volumeControlPosition );
                canvasCtx.lineTo(volumeControlX + volumeControlWidth, volumeControlPosition );
                canvasCtx.stroke();
                canvasCtx.closePath();
            }
        </script>
        
        <script>
            
            function draw() {
                analyser.getFloatTimeDomainData(timeDataArray);

                for (let i = 0; i < timeDataArray.length; i++) {
                    // Smooth the curve over time
                    firstTimeDerivative[i] += (timeDataArray[i] - firstTimeDerivative[i]) * 0.1;
                    secondTimeDerivative[i] += (firstTimeDerivative[i] - secondTimeDerivative[i]) * 0.1;
                }
                getCurrentSong().draw(canvasCtx);

                drawUI();
                requestAnimationFrame(draw);
            };

            // rename to startConcert
            loadFirstSong = () => {

                if(allSongsDoneLoading()) {
                    getCurrentSong().start(source);
                    source.start(0);
                    draw();
                } else {
                    console.log("Still Loading!");
                }
            }
        </script>
        <script>
            document.addEventListener("wheel", (eventObj) => {
                // event.preventDefault(); // Commented since this event is registered as 'passive'
                let value = gainNode.gain.value;
                value += Math.sign(event.deltaY) * -0.1;
                // value += event.deltaY * -0.001;
                // Restrict scale
                gainNode.gain.value = Math.min(Math.max(MIN_VOLUME, value), MAX_VOLUME);
            })
        </script>
    </body>
    
    <script src="lib/framework.js"></script>

    <!-- This also defines the order of the songs in the track list -->
    <script src="./resources/by_myslf/index.js"></script>
    <script src="./resources/in-the-end/index.js"></script>
    <script src="./resources/numb/index.js"></script>
    <script src="./resources/new-divide/index.js"></script>
    <script src="./resources/castle-of-glass/index.js"></script>
    
    <script src="./resources/wretches-and-kings/index.js"></script>
    <script src="./resources/heavy/index.js"></script>
    
    <script src="./resources/leave-out-all-the-rest/index.js"></script>
    <script src="./resources/iridescent/index.js"></script>
    <script src="./resources/the-messenger/index.js"></script>
    
    <script src="./resources/when-they-come-for-me/index.js"></script>
    <script src="./resources/final-masquerade/index.js"></script>
</html>